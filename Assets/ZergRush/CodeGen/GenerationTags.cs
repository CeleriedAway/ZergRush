using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using ZergRush.Alive;
using Newtonsoft.Json;
using UnityEngine;
using ZergRush.CodeGen;
using ZergRush.ReactiveCore;

namespace ZergRush.CodeGen
{
}

namespace ZergRush.CodeGen
{
    [Flags]
    public enum GenTaskFlags
    {
        None = 0,
        Hash = 2 << 0,
        UpdateFrom = 2 << 1,
        LifeSupport = 2 << 2,
        DefaultConstructor = 2 << 3,
        CompareChech = 2 << 4,
        OwnershipHierarchy = 2 << 5,
        PooledUpdateFrom = 2 << 6,
        Deserialize = 2 << 8,
        Serialize = 2 << 9,
        Pooled = 2 << 10,
        PooledDeserialize = 2 << 11,

        PolymorphicConstruction = 2 << 12,
        PooledPolymorphicConstruction = 2 << 13,
        JsonSerialization = 2 << 14,
        CommandsGen = 2 << 15,

        UIDGen = 2 << 16,
        CollectConfigs = 2 << 17,

        Serialization = Deserialize | Serialize,
        SimpleDataPack = DefaultConstructor | UpdateFrom | Hash | CompareChech | JsonSerialization | Serialization,

        PolymorphicDataPack = SimpleDataPack | PolymorphicConstruction,
        NodePack = PolymorphicDataPack | OwnershipHierarchy,
        LivableNodePack = NodePack | LifeSupport,

        PooledDataPack = DefaultConstructor | Hash | CompareChech | JsonSerialization | Pooled | PooledUpdateFrom |
                         PooledPolymorphicConstruction | PooledDeserialize,
        PooledNodePack = PooledDataPack | OwnershipHierarchy,
        PooledLivableNodePack = PooledNodePack | LifeSupport,

        ConfigData = Hash | Serialization | JsonSerialization | DefaultConstructor | PolymorphicConstruction |
                     CollectConfigs,

        All = 0xfffffff
    }

    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]
    public class CanBeNull : Attribute
    {
    }

    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]
// Useful to provide default value to cells in autogenerated constructors
    public class DefaultVal : Attribute
    {
        public object val;

        public DefaultVal(object val)
        {
            this.val = val;
        }
    }

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true)]
    public class GenTask : Attribute
    {
        public GenTaskFlags flags;

        public GenTask(GenTaskFlags flags)
        {
            this.flags = flags;
        }
    }

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Field | AttributeTargets.Property |
                    AttributeTargets.Struct)]
    public class GenIgnore : Attribute
    {
        public GenTaskFlags flags;

        public GenIgnore()
        {
            this.flags = GenTaskFlags.All;
        }

        public GenIgnore(GenTaskFlags flags)
        {
            this.flags = flags;
        }
    }

    // Needed if you want to store Livable object in hierarchy but wat it to behave just like usual data
    // Usefull if you store a prototype of a livable object
    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
    public class JustData : Attribute
    {
    }
}

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum, AllowMultiple = false)]
public class GenTargetFolder : Attribute
{
    public int priority;
    public string folder;

    public GenTargetFolder(string folder, int priority = 1)
    {
        this.folder = folder;
        this.priority = priority;
    }
}

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum, AllowMultiple = false)]
public class GenDefaultFolder : GenTargetFolder
{
    public GenDefaultFolder() : base(null)
    {
    }
}

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum, AllowMultiple = false)]
public class GenInLocalFolder : GenTargetFolder
{
    static string GetPath(string dir, string sourceFilePath = "")
    {
        var path = Path.GetDirectoryName(sourceFilePath);
        return path + $"\\{dir}";
    }
    
    public GenInLocalFolder(string dir = "x_generated", [CallerFilePath] string sourceFilePath = "") : base(GetPath(dir, sourceFilePath), 100)
    {
        //Debug.Log("~~~~~~~~~" + folder);
    }
}

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true)]
public class DoNotGen : Attribute
{
    public DoNotGen()
    {
    }
}

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true)]
public class GenSimpleData : GenTask
{
    public GenSimpleData() : base(GenTaskFlags.SimpleDataPack)
    {
    }
}

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true)]
public class GenConfigData : GenTask
{
    public GenConfigData() : base(GenTaskFlags.ConfigData)
    {
    }
}

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true)]
public class GenLoadableConfigData : GenTask
{
    public GenLoadableConfigData() : base(GenTaskFlags.ConfigData | GenTaskFlags.UIDGen)
    {
    }
}

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true)]
public class GenDoNotInheritGenTags : Attribute
{
}

[AttributeUsage(AttributeTargets.Class)]
public class GenCommands : GenTask
{
    public GenCommands() : base(GenTaskFlags.CommandsGen)
    {
    }
}

[AttributeUsage(AttributeTargets.Method)]
public class LocalCommand : Attribute
{
}

[AttributeUsage(AttributeTargets.Method)]
public class RemoteCommand : Attribute
{
}

[AttributeUsage(AttributeTargets.Method)]
public class IsDebug : Attribute
{
}

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true)]
public class GenLivable : GenTask
{
    public GenLivable() : base(GenTaskFlags.LivableNodePack)
    {
    }
}

[AttributeUsage(AttributeTargets.Class)]
public class GenModelRootSetup : Attribute
{
}


[AttributeUsage(AttributeTargets.Class)]
public class GenPolymorphicNode : Attribute
{
}

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Field | AttributeTargets.Property)]
public class Immutable : Attribute
{
}

[AttributeUsage(AttributeTargets.Class)]
public class HasRefId : Attribute
{
}

[AttributeUsage(AttributeTargets.Class)]
public class ConfigRootType : Attribute
{
    public Type type;

    public ConfigRootType(Type type)
    {
        this.type = type;
    }
}

[AttributeUsage(AttributeTargets.Class)]
public class RootType : Attribute
{
    public Type type;

    public RootType(Type type)
    {
        this.type = type;
    }
}

[AttributeUsage(AttributeTargets.Class)]
public class GenRemoteCommands : GenTask
{
    public Type requestType;
    public Type responseType;
    public string commandTypeName;
    public Type networkLayerType;

    public GenRemoteCommands(Type requestType, Type responseType, string commandTypeName, Type networkLayerType) : base(
        GenTaskFlags.CommandsGen)
    {
        this.requestType = requestType;
        this.responseType = responseType;
        this.commandTypeName = commandTypeName;
        this.networkLayerType = networkLayerType;
    }
}


[AttributeUsage(AttributeTargets.Class)]
public class GenUpdatedEvent : Attribute
{
}

public class __GenReplaceFieldBase : Attribute
{
    public int line;
    public string file;
    public string name;
    public Type type;
}

[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]
public class GenUICell : __GenReplaceFieldBase
{
    GenUICell genUICell;

    public GenUICell([CallerFilePath] string file = "",
        [CallerMemberName] string member = "",
        [CallerLineNumber] int line = 0)
    {
        this.line = line;
        this.file = file;
        this.name = member;
    }
}

[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]
public class GenRecordable : __GenReplaceFieldBase
{
    public GenRecordable(
        [CallerFilePath] string file = "",
        [CallerMemberName] string member = "",
        [CallerLineNumber] int line = 0)
    {
        this.line = line;
        this.file = file;
        this.name = member;
    }
}

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
public class GenTaskCustomImpl : GenTask
{
    public bool genBaseMethods;

    public GenTaskCustomImpl(GenTaskFlags flags, bool genBaseMethods = false) : base(flags)
    {
        this.flags = flags;
        this.genBaseMethods = genBaseMethods;
    }
}

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
public class GenSerialization : GenTask
{
    public GenSerialization() : base(GenTaskFlags.Serialization)
    {
    }
}


[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
public class GenHashing : GenTask
{
    public GenHashing() : base(GenTaskFlags.Hash)
    {
    }
}

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
public class GenUpdateFrom : GenTask
{
    public GenUpdateFrom() : base(GenTaskFlags.UpdateFrom)
    {
    }
}

[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]
public class SortedElements : Attribute
{
    public string numberGetter;

    public SortedElements(string numberGetter)
    {
        this.numberGetter = numberGetter;
    }
}


[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
public class GenInclude : Attribute
{
    public GenTaskFlags flags;

    public GenInclude()
    {
        this.flags = GenTaskFlags.All;
    }

    public GenInclude(GenTaskFlags flags)
    {
        this.flags = flags;
    }
}

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
public class CantBeAncestor : Attribute
{
}

// Says that this filed used in composition of unique identifier of this instance
[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
public class UIDComponent : Attribute
{
}

// Says that this field should be loaded from config, type should implement IUniquelyIdentifiable
[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
public class LoadFromConfig : Attribute
{
}


// If this attribute is set this static function will be called during main codegeneration
// process and you can request types for generation in main chunk with CodeGen.RequestGen
// and use CodeGen.context to gen modules and classes ect...
[AttributeUsage(AttributeTargets.Method)]
public class CodeGenExtension : Attribute
{
}